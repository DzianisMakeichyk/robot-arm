{"ast":null,"code":"var _jsxFileName = \"/Users/dzianismakeichyk/Documents/projects/robot-fun/robot-arm/hmi/src/components/gizmo/index.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport { useThree } from '@react-three/fiber';\nimport { Translate } from './Translate';\nimport { Rotate } from './Rotate';\nimport { context } from './context';\nimport { Vector3, Matrix4, Box3 } from 'three';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n// local matrices\nconst localMatrix0 = new Matrix4();\nconst localMatrix = new Matrix4();\nconst localMatrix0Inv = new Matrix4();\nconst localDeltaMatrix = new Matrix4();\n\n// world matrices\nconst worldMatrix0 = new Matrix4();\nconst worldMatrix = new Matrix4();\n\n// parent matrices\nconst parentMatrix = new Matrix4();\nconst parentMatrixInv = new Matrix4();\n\n/**\n * The Gizmo component accepts a configuration and the children (meshes) to control.\n *\n * Both Translate as Rotate is handled. The type of operation is depending on the\n * configuration of activeAxis, disableTranslation and disableRotation. Mixing operations\n * is supported. e.g. a gizmo to rotate and translate with.\n */\nexport const Gizmo = ({\n  scale = 1,\n  matrix,\n  anchor,\n  activeAxes = [true, true, true],\n  disableTranslation = false,\n  disableRotation = false,\n  translationLimits,\n  rotationLimits,\n  userData,\n  onUpdate,\n  children\n}) => {\n  _s();\n  // A handle to the underlying canvas invalidation method.\n  // [useThree] Accesses R3F's internal state (WebGL), containing renderer, canvas, scene, etc.\n  // [state.invalidate] flags the canvas for render, but doesn't render in itself\n  const invalidate = useThree(state => state.invalidate);\n\n  // grouping the gizmo and objects\n  const parentGroup = useRef(null);\n  const matrixGroup = useRef(null);\n  const gizmoGroup = useRef(null);\n  const childrenGroup = useRef(null);\n  useEffect(() => {\n    // if an anchor is given we adjust the gizmo position\n    if (anchor) {\n      // the group under control of this gizmo\n      const targetGroup = childrenGroup.current;\n\n      // calculate a bounding box to determine gizmo location\n      const boundingBox = new Box3();\n      if (targetGroup) {\n        // Update the global transform of the object group\n        targetGroup.updateWorldMatrix(true, true);\n\n        // Invert the matrix\n        parentMatrixInv.copy(targetGroup.matrixWorld).invert();\n\n        // Clear the bounding box for the new calculation\n        boundingBox.makeEmpty();\n\n        // traverse over the objects in the targetGroup\n        targetGroup.traverse(object => {\n          // calculate the bounding box for objects with geometry\n          if (!object.geometry) return;\n          if (!object.geometry.boundingBox) object.geometry.computeBoundingBox();\n          localMatrix.copy(object.matrixWorld).premultiply(parentMatrixInv);\n\n          // get the bounding box of this object\n          const objectBoundingBox = new Box3();\n          objectBoundingBox.copy(object.geometry.boundingBox);\n          objectBoundingBox.applyMatrix4(localMatrix);\n\n          // Computes the union of this boundingBox and objectBoundingBox, setting the upper bound of\n          // boundingBox to the greater of the two boxes' upper bounds and the lower bound of boundingBox\n          // to the lesser of the two boxes' lower bounds.\n          boundingBox.union(objectBoundingBox);\n        });\n\n        // calculate vectors\n        const vectorCenter = new Vector3();\n        const vectorSize = new Vector3();\n        vectorCenter.copy(boundingBox.max).add(boundingBox.min).multiplyScalar(0.5);\n        vectorSize.copy(boundingBox.max).sub(boundingBox.min).multiplyScalar(0.5);\n        const anchorOffsetVector = new Vector3();\n        const positionVector = new Vector3();\n        anchorOffsetVector.copy(vectorSize).multiply(new Vector3(...anchor)) // given anchor\n        .add(vectorCenter);\n        positionVector.set(0, 0, 0).add(anchorOffsetVector);\n\n        // copy the position to the gizmo group to apply gizmo anchor\n        gizmoGroup.current.position.copy(positionVector);\n        invalidate();\n      }\n    }\n  }, [anchor, invalidate]);\n\n  /**\n   * The Gizmo configuration contains scale, limits and userdata for the gizmo\n   * and holds the implementation for both Translate and Rotate matrix updates\n   * based on the gizmo mouse pointer events.\n   *\n   * This configuration is stored in Context, see the context.Provider below\n   *\n   * With useMemo we only recalculate when the dependencies have changed since the last render, more specific in\n   * this case when any of the onDragStart, onDrag, onDragEnd dependencies change\n   */\n  const configuration = {\n    /**\n     * onDragStart is invoked by the group onPointerDown with the information on\n     * what operation (Translate/Rotate) which axis, origin and direction array\n     */\n    onDragStart: () => {\n      // @todo learn about matrix operations\n      localMatrix0.copy(matrixGroup.current.matrix);\n      worldMatrix0.copy(matrixGroup.current.matrixWorld);\n      invalidate();\n    },\n    /**\n     * onDrag is invoked by the group onPointerMove method\n     * which calculated the delta matrix\n     */\n    onDrag: worldDeltaMatrix => {\n      // @todo learn about matrix operations\n      parentMatrix.copy(parentGroup.current.matrixWorld);\n      parentMatrixInv.copy(parentMatrix).invert();\n\n      // After applying the delta\n      worldMatrix.copy(worldMatrix0).premultiply(worldDeltaMatrix);\n      localMatrix.copy(worldMatrix).premultiply(parentMatrixInv);\n      localMatrix0Inv.copy(localMatrix0).invert();\n      localDeltaMatrix.copy(localMatrix).multiply(localMatrix0Inv);\n\n      // @todo point of interest, the update of matrix group with change\n      matrixGroup.current.matrix.copy(localMatrix);\n\n      // console.log(1, 'matrixGroup:', matrixGroup)\n\n      // Extract the new position from the matrix\n      const position = new Vector3().setFromMatrixPosition(matrixGroup.current.matrix);\n\n      // Call onUpdate with the new position\n      // if (onUpdate) {\n      //     onUpdate(position.toArray() as [number, number, number])\n      // }\n\n      invalidate();\n    },\n    /**\n     * Mouse/pointer up\n     */\n    onDragEnd: () => {\n      invalidate();\n    },\n    translationLimits,\n    rotationLimits,\n    scale,\n    userData\n  };\n  return /*#__PURE__*/_jsxDEV(context.Provider, {\n    value: configuration,\n    children: /*#__PURE__*/_jsxDEV(\"group\", {\n      ref: parentGroup,\n      children: /*#__PURE__*/_jsxDEV(\"group\", {\n        ref: matrixGroup,\n        matrix: matrix,\n        matrixAutoUpdate: false,\n        children: [/*#__PURE__*/_jsxDEV(\"group\", {\n          ref: gizmoGroup,\n          children: [!disableTranslation && /*#__PURE__*/_jsxDEV(_Fragment, {\n            children: [activeAxes[0] && /*#__PURE__*/_jsxDEV(Translate, {\n              axis: 0\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 206,\n              columnNumber: 53\n            }, this), activeAxes[1] && /*#__PURE__*/_jsxDEV(Translate, {\n              axis: 1\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 207,\n              columnNumber: 53\n            }, this), activeAxes[2] && /*#__PURE__*/_jsxDEV(Translate, {\n              axis: 2\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 208,\n              columnNumber: 53\n            }, this)]\n          }, void 0, true), !disableRotation && /*#__PURE__*/_jsxDEV(_Fragment, {\n            children: [activeAxes[0] && activeAxes[1] && /*#__PURE__*/_jsxDEV(Rotate, {\n              axis: 2\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 215,\n              columnNumber: 70\n            }, this), activeAxes[0] && activeAxes[2] && /*#__PURE__*/_jsxDEV(Rotate, {\n              axis: 1\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 216,\n              columnNumber: 70\n            }, this), activeAxes[2] && activeAxes[1] && /*#__PURE__*/_jsxDEV(Rotate, {\n              axis: 0\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 217,\n              columnNumber: 70\n            }, this)]\n          }, void 0, true)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 201,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"group\", {\n          ref: childrenGroup,\n          children: children\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 223,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 197,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 195,\n    columnNumber: 13\n  }, this);\n};\n_s(Gizmo, \"3MNhxcf7pVjycNJbi9+RzXLcxMU=\", false, function () {\n  return [useThree];\n});\n_c = Gizmo;\nvar _c;\n$RefreshReg$(_c, \"Gizmo\");","map":{"version":3,"names":["React","useEffect","useRef","useThree","Translate","Rotate","context","Vector3","Matrix4","Box3","jsxDEV","_jsxDEV","Fragment","_Fragment","localMatrix0","localMatrix","localMatrix0Inv","localDeltaMatrix","worldMatrix0","worldMatrix","parentMatrix","parentMatrixInv","Gizmo","scale","matrix","anchor","activeAxes","disableTranslation","disableRotation","translationLimits","rotationLimits","userData","onUpdate","children","_s","invalidate","state","parentGroup","matrixGroup","gizmoGroup","childrenGroup","targetGroup","current","boundingBox","updateWorldMatrix","copy","matrixWorld","invert","makeEmpty","traverse","object","geometry","computeBoundingBox","premultiply","objectBoundingBox","applyMatrix4","union","vectorCenter","vectorSize","max","add","min","multiplyScalar","sub","anchorOffsetVector","positionVector","multiply","set","position","configuration","onDragStart","onDrag","worldDeltaMatrix","setFromMatrixPosition","onDragEnd","Provider","value","ref","matrixAutoUpdate","axis","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dzianismakeichyk/Documents/projects/robot-fun/robot-arm/hmi/src/components/gizmo/index.tsx"],"sourcesContent":[" \nimport React, {useEffect, useRef} from 'react'\nimport {useThree} from '@react-three/fiber'\nimport {Translate} from './Translate'\nimport {Rotate} from './Rotate'\nimport {context} from './context'\nimport {Vector3, Matrix4, Box3, Group} from 'three'\nimport {Robot} from '@types'\n\n// local matrices\nconst localMatrix0 = new Matrix4()\nconst localMatrix = new Matrix4()\nconst localMatrix0Inv = new Matrix4()\nconst localDeltaMatrix = new Matrix4()\n\n// world matrices\nconst worldMatrix0 = new Matrix4()\nconst worldMatrix = new Matrix4()\n\n// parent matrices\nconst parentMatrix = new Matrix4()\nconst parentMatrixInv = new Matrix4()\n\n/**\n * The Gizmo component accepts a configuration and the children (meshes) to control.\n *\n * Both Translate as Rotate is handled. The type of operation is depending on the\n * configuration of activeAxis, disableTranslation and disableRotation. Mixing operations\n * is supported. e.g. a gizmo to rotate and translate with.\n */\nexport const Gizmo = ((\n        {\n            scale = 1,\n            matrix,\n            anchor,\n            activeAxes = [true, true, true],\n            disableTranslation = false,\n            disableRotation = false,\n            translationLimits,\n            rotationLimits,\n            userData,\n            onUpdate,\n            children,\n        }: Robot.GizmoProperties) => {\n\n        // A handle to the underlying canvas invalidation method.\n        // [useThree] Accesses R3F's internal state (WebGL), containing renderer, canvas, scene, etc.\n        // [state.invalidate] flags the canvas for render, but doesn't render in itself\n        const invalidate = useThree((state) => state.invalidate)\n\n        // grouping the gizmo and objects\n        const parentGroup = useRef<Group>(null!)\n        const matrixGroup = useRef<Group>(null!)\n        const gizmoGroup = useRef<Group>(null!)\n        const childrenGroup = useRef<Group>(null!)\n\n        useEffect(() => {\n\n            // if an anchor is given we adjust the gizmo position\n            if (anchor) {\n\n                // the group under control of this gizmo\n                const targetGroup = childrenGroup.current\n\n                // calculate a bounding box to determine gizmo location\n                const boundingBox = new Box3()\n\n                if (targetGroup) {\n\n                    // Update the global transform of the object group\n                    targetGroup.updateWorldMatrix(true, true)\n\n                    // Invert the matrix\n                    parentMatrixInv.copy(targetGroup.matrixWorld).invert()\n\n                    // Clear the bounding box for the new calculation\n                    boundingBox.makeEmpty()\n\n                    // traverse over the objects in the targetGroup\n                    targetGroup.traverse((object: any) => {\n\n                        // calculate the bounding box for objects with geometry\n                        if (!object.geometry) return\n                        if (!object.geometry.boundingBox) object.geometry.computeBoundingBox()\n\n                        localMatrix.copy(object.matrixWorld).premultiply(parentMatrixInv)\n\n                        // get the bounding box of this object\n                        const objectBoundingBox = new Box3()\n                        objectBoundingBox.copy(object.geometry.boundingBox)\n                        objectBoundingBox.applyMatrix4(localMatrix)\n\n                        // Computes the union of this boundingBox and objectBoundingBox, setting the upper bound of\n                        // boundingBox to the greater of the two boxes' upper bounds and the lower bound of boundingBox\n                        // to the lesser of the two boxes' lower bounds.\n                        boundingBox.union(objectBoundingBox)\n                    })\n\n                    // calculate vectors\n                    const vectorCenter = new Vector3()\n                    const vectorSize = new Vector3()\n\n                    vectorCenter.copy(boundingBox.max).add(boundingBox.min).multiplyScalar(0.5)\n                    vectorSize.copy(boundingBox.max).sub(boundingBox.min).multiplyScalar(0.5)\n\n                    const anchorOffsetVector = new Vector3()\n                    const positionVector = new Vector3()\n\n                    anchorOffsetVector\n                        .copy(vectorSize)\n                        .multiply(new Vector3(...anchor)) // given anchor\n                        .add(vectorCenter)\n\n                    positionVector.set(0, 0, 0).add(anchorOffsetVector)\n\n                    // copy the position to the gizmo group to apply gizmo anchor\n                    gizmoGroup.current.position.copy(positionVector)\n\n                    invalidate()\n                }\n            }\n\n        }, [anchor, invalidate])\n\n        /**\n         * The Gizmo configuration contains scale, limits and userdata for the gizmo\n         * and holds the implementation for both Translate and Rotate matrix updates\n         * based on the gizmo mouse pointer events.\n         *\n         * This configuration is stored in Context, see the context.Provider below\n         *\n         * With useMemo we only recalculate when the dependencies have changed since the last render, more specific in\n         * this case when any of the onDragStart, onDrag, onDragEnd dependencies change\n         */\n        const configuration = {\n\n            /**\n             * onDragStart is invoked by the group onPointerDown with the information on\n             * what operation (Translate/Rotate) which axis, origin and direction array\n             */\n            onDragStart: () => {\n\n                // @todo learn about matrix operations\n                localMatrix0.copy(matrixGroup.current.matrix)\n                worldMatrix0.copy(matrixGroup.current.matrixWorld)\n                invalidate()\n            },\n\n            /**\n             * onDrag is invoked by the group onPointerMove method\n             * which calculated the delta matrix\n             */\n            onDrag: (worldDeltaMatrix: Matrix4) => {\n\n                // @todo learn about matrix operations\n                parentMatrix.copy(parentGroup.current.matrixWorld)\n                parentMatrixInv.copy(parentMatrix).invert()\n\n                // After applying the delta\n                worldMatrix.copy(worldMatrix0).premultiply(worldDeltaMatrix)\n                localMatrix.copy(worldMatrix).premultiply(parentMatrixInv)\n                localMatrix0Inv.copy(localMatrix0).invert()\n                localDeltaMatrix.copy(localMatrix).multiply(localMatrix0Inv)\n\n                // @todo point of interest, the update of matrix group with change\n                matrixGroup.current.matrix.copy(localMatrix)\n\n                // console.log(1, 'matrixGroup:', matrixGroup)\n\n                // Extract the new position from the matrix\n                const position = new Vector3().setFromMatrixPosition(matrixGroup.current.matrix)\n                \n                // Call onUpdate with the new position\n                // if (onUpdate) {\n                //     onUpdate(position.toArray() as [number, number, number])\n                // }\n\n                invalidate()\n            },\n\n            /**\n             * Mouse/pointer up\n             */\n            onDragEnd: () => {\n                invalidate()\n            },\n\n            translationLimits,\n            rotationLimits,\n            scale,\n            userData\n        }\n\n        return (\n            <context.Provider value={configuration}>\n\n                <group ref={parentGroup}>\n\n                    <group ref={matrixGroup} matrix={matrix} matrixAutoUpdate={false}>\n\n                        <group ref={gizmoGroup}>\n\n                            {\n                                !disableTranslation &&\n                              <>\n                                  {activeAxes[0] && <Translate axis={0}/>}\n                                  {activeAxes[1] && <Translate axis={1}/>}\n                                  {activeAxes[2] && <Translate axis={2}/>}\n                              </>\n                            }\n\n                            {\n                                !disableRotation &&\n                              <>\n                                  {activeAxes[0] && activeAxes[1] && <Rotate axis={2}/>}\n                                  {activeAxes[0] && activeAxes[2] && <Rotate axis={1}/>}\n                                  {activeAxes[2] && activeAxes[1] && <Rotate axis={0}/>}\n                              </>\n                            }\n\n                        </group>\n\n                        <group ref={childrenGroup}>{children}</group>\n\n                    </group>\n\n                </group>\n            </context.Provider>\n        )\n    }\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}