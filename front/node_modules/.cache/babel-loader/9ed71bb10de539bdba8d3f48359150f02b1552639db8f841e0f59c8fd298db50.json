{"ast":null,"code":"import { Vector3 } from \"three\";\n\n/**\n * Calculate degrees from radians\n * @param radians\n */\nconst toDegrees = radians => radians * 180 / Math.PI;\n\n/**\n * Calculate radians from degrees\n * @param degrees\n */\nconst toRadians = degrees => degrees * Math.PI / 180;\n\n/**\n *\n * @param clickPoint\n * @param intersectionPoint\n * @param origin\n * @param e1\n * @param e2\n */\nconst calculateAngle = (clickPoint, intersectionPoint, origin, e1, e2) => {\n  const clickDir = new Vector3();\n  const intersectionDir = new Vector3();\n  clickDir.copy(clickPoint).sub(origin);\n  intersectionDir.copy(intersectionPoint).sub(origin);\n  const dote1e1 = e1.dot(e1);\n  const dote2e2 = e2.dot(e2);\n  const uClick = clickDir.dot(e1) / dote1e1;\n  const vClick = clickDir.dot(e2) / dote2e2;\n  const uIntersection = intersectionDir.dot(e1) / dote1e1;\n  const vIntersection = intersectionDir.dot(e2) / dote2e2;\n  const angleClick = Math.atan2(vClick, uClick);\n  const angleIntersection = Math.atan2(vIntersection, uIntersection);\n  return angleIntersection - angleClick;\n};\n\n/**\n *\n * @param num\n * @param denom\n */\nconst fmod = (num, denom) => {\n  let k = Math.floor(num / denom);\n  k = k < 0 ? k + 1 : k;\n  return num - k * denom;\n};\n\n/**\n *\n * @param angle\n */\nconst minimizeAngle = angle => {\n  let result = fmod(angle, 2 * Math.PI);\n  if (Math.abs(result) < 1e-6) {\n    return 0.0;\n  }\n  if (result < 0.0) {\n    result += 2 * Math.PI;\n  }\n  return result;\n};\n\n/**\n * Helper method to calculate the offset when determining\n * if we are still within translation limits\n * @todo move to utils\n */\nconst calculateOffset = (clickPoint, normal, rayStart, rayDir) => {\n  const vec1 = new Vector3();\n  const vec2 = new Vector3();\n  const e1 = normal.dot(normal);\n  const e2 = normal.dot(clickPoint) - normal.dot(rayStart);\n  const e3 = normal.dot(rayDir);\n  if (e3 === 0) return -e2 / e1;\n  vec1.copy(rayDir).multiplyScalar(e1 / e3).sub(normal);\n  vec2.copy(rayDir).multiplyScalar(e2 / e3).add(rayStart).sub(clickPoint);\n  return -vec1.dot(vec2) / vec1.dot(vec1);\n};\nexport { toDegrees, toRadians, calculateAngle, fmod, minimizeAngle, calculateOffset };","map":{"version":3,"names":["Vector3","toDegrees","radians","Math","PI","toRadians","degrees","calculateAngle","clickPoint","intersectionPoint","origin","e1","e2","clickDir","intersectionDir","copy","sub","dote1e1","dot","dote2e2","uClick","vClick","uIntersection","vIntersection","angleClick","atan2","angleIntersection","fmod","num","denom","k","floor","minimizeAngle","angle","result","abs","calculateOffset","normal","rayStart","rayDir","vec1","vec2","e3","multiplyScalar","add"],"sources":["/Users/dzianismakeichyk/Documents/projects/robot-fun/robot-arm/hmi/src/utils/index.ts"],"sourcesContent":[" \nimport {Vector3} from \"three\";\n\n/**\n * Calculate degrees from radians\n * @param radians\n */\nconst toDegrees = (radians: number) => (radians * 180) / Math.PI\n\n/**\n * Calculate radians from degrees\n * @param degrees\n */\nconst toRadians = (degrees: number) => (degrees * Math.PI) / 180\n\n/**\n *\n * @param clickPoint\n * @param intersectionPoint\n * @param origin\n * @param e1\n * @param e2\n */\nconst calculateAngle = (clickPoint: Vector3, intersectionPoint: Vector3, origin: Vector3, e1: Vector3, e2: Vector3) => {\n\n    const clickDir = new Vector3()\n    const intersectionDir = new Vector3()\n\n    clickDir.copy(clickPoint).sub(origin)\n    intersectionDir.copy(intersectionPoint).sub(origin)\n\n    const dote1e1 = e1.dot(e1)\n    const dote2e2 = e2.dot(e2)\n    const uClick = clickDir.dot(e1) / dote1e1\n    const vClick = clickDir.dot(e2) / dote2e2\n    const uIntersection = intersectionDir.dot(e1) / dote1e1\n    const vIntersection = intersectionDir.dot(e2) / dote2e2\n    const angleClick = Math.atan2(vClick, uClick)\n    const angleIntersection = Math.atan2(vIntersection, uIntersection)\n\n    return angleIntersection - angleClick\n}\n\n/**\n *\n * @param num\n * @param denom\n */\nconst fmod = (num: number, denom: number) => {\n\n    let k = Math.floor(num / denom)\n    k = k < 0 ? k + 1 : k\n\n    return num - k * denom\n}\n\n/**\n *\n * @param angle\n */\nconst minimizeAngle = (angle: number) => {\n\n    let result = fmod(angle, 2 * Math.PI)\n\n    if (Math.abs(result) < 1e-6) {\n        return 0.0\n    }\n\n    if (result < 0.0) {\n        result += 2 * Math.PI\n    }\n\n    return result\n}\n\n/**\n * Helper method to calculate the offset when determining\n * if we are still within translation limits\n * @todo move to utils\n */\nconst calculateOffset = (clickPoint: Vector3, normal: Vector3, rayStart: Vector3, rayDir: Vector3) => {\n\n    const vec1 = new Vector3()\n    const vec2 = new Vector3()\n    const e1 = normal.dot(normal)\n    const e2 = normal.dot(clickPoint) - normal.dot(rayStart)\n    const e3 = normal.dot(rayDir)\n\n    if (e3 === 0) return -e2 / e1\n\n    vec1.copy(rayDir).multiplyScalar(e1 / e3).sub(normal)\n    vec2.copy(rayDir).multiplyScalar(e2 / e3).add(rayStart).sub(clickPoint)\n\n    return -vec1.dot(vec2) / vec1.dot(vec1)\n}\n\nexport {\n    toDegrees,\n    toRadians,\n    calculateAngle,\n    fmod,\n    minimizeAngle,\n    calculateOffset\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}