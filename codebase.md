# .gitignore

```
# dependencies
hmi/node_modules/
api/node_modules/

# IDE
.idea

# Docker
.docker

# MongoDB Data
data

# build
api/dist
api/debug.log

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

```

# data/_mdb_catalog.wt

This is a binary file of the type: Binary

# data/collection-0--188536456211366303.wt

This is a binary file of the type: Binary

# data/collection-0--1093803086368506637.wt

This is a binary file of the type: Binary

# data/collection-2--1093803086368506637.wt

This is a binary file of the type: Binary

# data/collection-4--1093803086368506637.wt

This is a binary file of the type: Binary

# data/collection-8--549222828002248186.wt

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-16T13-36-39Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-16T15-26-12Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-16T15-28-48Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-16T16-02-18Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T08-41-12Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T08-45-45Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T08-46-40Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T08-56-07Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T08-58-01Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T09-00-09Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T09-01-17Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T09-05-22Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T09-08-50Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T09-34-08Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T09-36-04Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T09-37-32Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T15-20-47Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T15-22-13Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T15-42-21Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T15-43-17Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-17T15-47-18Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-19T19-10-41Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T10-27-26Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T10-51-19Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T10-59-17Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T11-00-24Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T11-04-39Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T11-06-57Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T11-09-48Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-21T11-12-44Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-22T07-42-44Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-22-16Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-27-44Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-33-53Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-40-41Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-43-54Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-52-04Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-53-58Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-55-34Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T13-57-08Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T14-01-22Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T15-07-58Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T15-12-19Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T15-31-46Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T15-39-39Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T15-47-21Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-23T15-53-40Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-24T06-47-58Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-24T07-33-29Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-24T07-53-03Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-24T07-57-34Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-24T08-03-45Z-00000

This is a binary file of the type: Binary

# data/diagnostic.data/metrics.2024-10-24T08-12-21Z-00000

This is a binary file of the type: Binary

# data/index-1--188536456211366303.wt

This is a binary file of the type: Binary

# data/index-1--1093803086368506637.wt

This is a binary file of the type: Binary

# data/index-3--1093803086368506637.wt

This is a binary file of the type: Binary

# data/index-5--1093803086368506637.wt

This is a binary file of the type: Binary

# data/index-6--1093803086368506637.wt

This is a binary file of the type: Binary

# data/index-9--549222828002248186.wt

This is a binary file of the type: Binary

# data/journal/WiredTigerLog.0000000052

This is a binary file of the type: Binary

# data/journal/WiredTigerPreplog.0000000001

This is a binary file of the type: Binary

# data/journal/WiredTigerPreplog.0000000002

This is a binary file of the type: Binary

# data/mongod.lock

```lock

```

# data/sizeStorer.wt

This is a binary file of the type: Binary

# data/storage.bson

This is a binary file of the type: Binary

# data/WiredTiger

```
WiredTiger
WiredTiger 3.2.0: (May  9, 2019)

```

# data/WiredTiger.lock

```lock
WiredTiger lock file

```

# data/WiredTiger.turtle

```turtle
WiredTiger version string
WiredTiger 3.2.0: (May  9, 2019)
WiredTiger version
major=3,minor=2,patch=0
file:WiredTiger.wt
access_pattern_hint=none,allocation_size=4KB,app_metadata=,assert=(commit_timestamp=none,durable_timestamp=none,read_timestamp=none),block_allocation=best,block_compressor=,cache_resident=false,checkpoint=(WiredTigerCheckpoint.319=(addr="018081e4f733fb958181e42d0b01d38281e491c12dba808080e29fc0e22fc0",order=319,time=1729757888,size=24576,newest_durable_ts=0,oldest_start_ts=0,oldest_start_txn=0,newest_stop_ts=-1,newest_stop_txn=-11,write_gen=803)),checkpoint_lsn=(52,8960),checksum=uncompressed,collator=,columns=,dictionary=0,encryption=(keyid=,name=),format=btree,huffman_key=,huffman_value=,id=0,ignore_in_memory_cache_size=false,internal_item_max=0,internal_key_max=0,internal_key_truncate=true,internal_page_max=4KB,key_format=S,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=32KB,leaf_value_max=0,log=(enabled=true),memory_page_image_max=0,memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=false,prefix_compression_min=4,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=90,value_format=S,version=(major=1,minor=1)

```

# data/WiredTiger.wt

This is a binary file of the type: Binary

# data/WiredTigerLAS.wt

This is a binary file of the type: Binary

# docker-entrypoint.sh

```sh

```

# ev3dev/ev3.py

```py
#!/usr/bin/env python3
import socket
import base64
import random
import hashlib
import json
from ev3dev2.motor import (
    Motor,
    LargeMotor,
    MediumMotor,
    OUTPUT_A,
    OUTPUT_B,
    OUTPUT_C
)
import os

# Globalne zmienne dla silników
motors = {
    'A': None,
    'B': None,
    'C': None
}

# Default robot state
DEFAULT_ROBOT_STATE = {
    "nodes": {
        "main_column": {
            "position": [0, 1.462, 0],
            "scale": [1, 1, 1],
            "rotation": [0, 0, 0]
        },
        "upper_arm": {
            "position": [2.335, 0, 0.094],
            "scale": [0.684, 1, 1],
            "rotation": [0, 0, 0]
        },
        "wrist_extension": {
            "position": [3.231, 6.551, 0.007],
            "scale": [0.264, 0.264, 0.264],
            "rotation": [0, 0, 0]
        },
        "hand": {
            "position": [3.368, 5.728, -0.119],
            "scale": [1, 0.068, 0.327],
            "rotation": [0, 1.5708, 0]
        },
        "gripper": {
            "position": [3.33, 5.545, 0.006],
            "scale": [-0.01, -0.132, -0.325],
            "rotation": [0, 1.5708, 0]
        }
    }
}

def check_motors():
    """Check which motors are connected"""
    motors = {}
    print("Scanning for motors...")
    
    # List all motor devices
    try:
        motor_path = "/sys/class/tacho-motor/"
        if os.path.exists(motor_path):
            devices = os.listdir(motor_path)
            print("Found devices: " + str(devices))
            
            for device in devices:
                try:
                    with open(os.path.join(motor_path, device, 'address'), 'r') as f:
                        port = f.read().strip()
                        with open(os.path.join(motor_path, device, 'driver_name'), 'r') as f:
                            driver = f.read().strip()
                        print("Found " + driver + " on port: " + port)
                except:
                    print("Cannot read info for device: " + device)
    except Exception as e:
        print("Error scanning devices: " + str(e))

    # Try to initialize motors
    for port in [OUTPUT_A, OUTPUT_B, OUTPUT_C]:
        try:
            motor = get_motor(port)
            if motor:
                port_name = port.strip('ev3-ports:out')
                motors[port] = True
                print("Motor on port " + port_name + " initialized successfully")
            else:
                port_name = port.strip('ev3-ports:out')
                motors[port] = False
                print("No motor found on port " + port_name)
        except Exception as e:
            port_name = port.strip('ev3-ports:out')
            motors[port] = False
            print("Error on port " + port_name + ": " + str(e))
    return motors

def get_motor(port):
    """Safely get motor instance with correct type"""
    try:
        # Sprawdź typ silnika
        motor_path = "/sys/class/tacho-motor/"
        for device in os.listdir(motor_path):
            with open(os.path.join(motor_path, device, 'address'), 'r') as f:
                if port in f.read():
                    # Sprawdź czy to średni czy duży silnik
                    with open(os.path.join(motor_path, device, 'driver_name'), 'r') as f:
                        driver = f.read()
                        if 'lego-ev3-m-motor' in driver:
                            print("Initializing Medium Motor on " + port)
                            return MediumMotor(port)
                        else:
                            print("Initializing Large Motor on " + port)
                            return LargeMotor(port)
    except Exception as e:
        print("Error initializing motor on port " + port + ": " + str(e))
        return None

def convert_to_motor_angle(rotation, motor_type):
    # Convert radians to degrees
    degrees = (rotation * 180) / 3.14159
    
    # Apply motor-specific limits and scaling
    if motor_type == "BASE":
        return max(-180, min(180, degrees))
    elif motor_type == "ELBOW":
        return max(-90, min(90, degrees))
    elif motor_type == "HEIGHT":
        return max(0, min(120, degrees))
    return 0

def decode_message(data):
    try:
        if len(data) < 2:
            return None

        # Próbuj jako WebSocket frame
        if data[0] == 0x81:
            second_byte = data[1] & 0x7F
            mask_start = 2
            payload_length = 0

            if second_byte <= 125:
                payload_length = second_byte
            elif second_byte == 126:
                if len(data) < 4:
                    return None
                payload_length = (data[2] << 8) | data[3]
                mask_start = 4
                
            mask = data[mask_start:mask_start + 4]
            payload = bytearray()
            
            for i in range(mask_start + 4, mask_start + 4 + payload_length):
                payload.append(data[i] ^ mask[(i - (mask_start + 4)) % 4])

            return payload.decode('utf-8')

        # Jeśli to nie WebSocket frame, próbuj jako base64
        try:
            decoded = base64.b64decode(data)
            if decoded.startswith(b'{'):
                return decoded.decode('utf-8')
        except:
            pass

        # Próbuj jako surowe bajty
        try:
            if data.startswith(b'{'):
                return data.decode('utf-8')
        except:
            pass

        return None

    except Exception as e:
        print("Decode error: " + str(e))
        return None

def create_websocket_frame(data):
    """Simple WebSocket frame encoder"""
    try:
        if isinstance(data, str):
            data = data.encode('utf-8')

        length = len(data)
        frame = bytearray()
        frame.append(0x81)  # Text frame

        if length <= 125:
            frame.append(length)
        elif length <= 65535:
            frame.append(126)
            frame.append((length >> 8) & 0xFF)
            frame.append(length & 0xFF)
        else:
            return None  # Don't handle huge frames

        frame.extend(data)
        return bytes(frame)
    except Exception as e:
        print("Encode error: " + str(e))
        return None

def initialize_motors():
    """Initialize motors once"""
    print("Initializing motors...")
    try:
        motors['A'] = MediumMotor(OUTPUT_A)
        print("Medium Motor on port A initialized")
    except Exception as e:
        print("Error initializing port A: " + str(e))

    try:
        motors['B'] = LargeMotor(OUTPUT_B)
        print("Large Motor on port B initialized")
    except Exception as e:
        print("Error initializing port B: " + str(e))

    try:
        motors['C'] = LargeMotor(OUTPUT_C)
        print("Large Motor on port C initialized")
    except Exception as e:
        print("Error initializing port C: " + str(e))

def handle_robot_update(data):
    """Handle robot update using global motors"""
    try:
        state = json.loads(data)
        if 'action' in state:
            del state['action']
            
        nodes = state.get('nodes', {})
        response = {"status": "success", "message": [], "state": state}
        
        updated_node = None
        for node_name, node_data in nodes.items():
            if 'rotation' in node_data and node_data.get('_updated', False):
                updated_node = node_name
                break

        if updated_node == 'gripper' and motors['A']:
            rotation = nodes['gripper']['rotation'][1]
            angle = (rotation * 180) / 3.14159
            angle = max(-180, min(180, angle))
            try:
                motors['A'].on_for_degrees(speed=20, degrees=random.randint(-2, 2))
                response["message"].append("Gripper motor moved")
            except Exception as e:
                response["message"].append("Gripper motor error: " + str(e))

        elif updated_node == 'upper_arm' and motors['B']:
            rotation = nodes['upper_arm']['rotation'][1]
            angle = (rotation * 180) / 3.14159
            angle = max(-90, min(90, angle))
            try:
                motors['B'].on_for_degrees(speed=20, degrees=random.randint(-2, 2))
                response["message"].append("Height motor moved")
            except Exception as e:
                response["message"].append("Height motor error: " + str(e))

        elif updated_node == 'main_column' and motors['C']:
            rotation = nodes['main_column']['rotation'][1]
            angle = (rotation * 180) / 3.14159
            angle = max(0, min(120, angle))
            try:
                motors['C'].on_for_degrees(speed=20, degrees=random.randint(-2, 2))
                response["message"].append("Base motor moved")
            except Exception as e:
                response["message"].append("Base motor error: " + str(e))
            
        response["message"] = "; ".join(response["message"])
        return response
    except Exception as e:
        return {"status": "error", "message": str(e)}

# Inicjalizacja silników przy starcie
initialize_motors()

print("Checking available motors...")
available_motors = check_motors()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.bind(('0.0.0.0', 4000))
server.listen(1)
print("Server started on port 4000")

BYTES = [0x6e, 0x66, 0x48, 0x2e, 0x3, 0xc7, 0xad, 0xa6, 0xfa]

def is_valid_json_frame(data):
   try:
       if data[0] == 0x81:  # WebSocket text frame
           mask_start = 2
           payload_length = data[1] & 0x7F
           
           if payload_length == 126:
               if len(data) < 4:
                   return False
               payload_length = (data[2] << 8) | data[3]
               mask_start = 4

           if len(data) < mask_start + 4 + payload_length:
               return False

           mask = data[mask_start:mask_start + 4]
           payload = bytearray()
           
           for i in range(mask_start + 4, mask_start + 4 + payload_length):
               payload.append(data[i] ^ mask[(i - (mask_start + 4)) % 4])

           decoded = payload.decode('utf-8')
           json.loads(decoded)  # Sprawdź czy to JSON
           return True
   except:
       return False
   return False

while True:
    try:
        client, addr = server.accept()
        print("Connected from: " + str(addr))
        
        data = client.recv(1024)
        text_data = data.decode('utf-8', errors='ignore')
        
        if "Upgrade: websocket" in text_data:
            key = ""
            for line in text_data.split('\n'):
                if "Sec-WebSocket-Key" in line:
                    key = line.split(': ')[1].strip()
                    
            if key:
                accept = base64.b64encode(
                    hashlib.sha1((key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11").encode())
                    .digest()
                ).decode()
                
                response = (
                    "HTTP/1.1 101 Switching Protocols\r\n"
                    "Upgrade: websocket\r\n"
                    "Connection: Upgrade\r\n"
                    "Sec-WebSocket-Accept: " + accept + "\r\n"
                    "\r\n"
                )
                client.send(response.encode())
                print("WebSocket connection established")
                
                # Send initial state
                initial_state = {"status": "success", "state": DEFAULT_ROBOT_STATE}
                client.send(create_websocket_frame(json.dumps(initial_state)))
                
                while True:
                  try:
                      data = client.recv(1024)
                      if not data:
                          print("Client disconnected")
                          break
                      
                    #   if data[0] in BYTES:  # Pomijamy niepoprawne ramki
                    #       continue
                      
                      if not is_valid_json_frame(data):
                          continue

                      message = decode_message(data)
                      if message:
                          print("Received message:", message)
                          try:
                              parsed = json.loads(message)
                              if "action" in parsed:
                                  if parsed["action"] == "test_motor":
                                      try:
                                          if motors['A']:
                                              print("Running motor test")
                                            #   motors['A'].on_for_rotations(speed=50, rotations=1)
                                            #   response = {"status": "success", "message": "Motor test completed"}
                                          else:
                                              response = {"status": "error", "message": "Motor not available"}
                                      except Exception as e:
                                          response = {"status": "error", "message": str(e)}
                                  elif parsed["action"] == "update":
                                      print("===>>> Handling robot update <<<===")
                                      response = handle_robot_update(message)
                                  else:
                                      response = {"status": "error", "message": "Unknown action"}

                                  frame = create_websocket_frame(json.dumps(response))
                                  if frame:
                                      client.send(frame)
                          except Exception as e:
                              print("Error processing message: " + str(e))
                      else:
                          print("===>>> Skipping invalid data" + str(data))
                          print("===>>> Skipping invalid message" + str(message))

                  except Exception as e:
                      print("Socket error: " + str(e))
                      break
    except Exception as e:
        print("Main loop error: " + str(e))
    finally:
        client.close()
```

# ev3dev/motor_test.py

```py
#!/usr/bin/env python3
from ev3dev2.motor import LargeMotor, OUTPUT_A
from time import sleep

# Initialize Motor A
motor = LargeMotor(OUTPUT_A)

# Run the motor forward at 50% speed
motor.on(speed=50)

# Let the motor run for 2 seconds
sleep(2)

# Stop the motor
motor.off()
```

# ev3dev/websocket_proxy.py

```py
#!/usr/bin/env python3
import socket
import select
import base64
import hashlib

BROWSER_PORT = 4001
EV3_HOST = '192.168.2.3' 
EV3_PORT = 4000

def handle_websocket_connection(browser_socket, ev3_socket):
    # Ustaw non-blocking mode
    browser_socket.setblocking(0)
    ev3_socket.setblocking(0)
    
    inputs = [browser_socket, ev3_socket]
    
    while True:
        try:
            readable, _, exceptional = select.select(inputs, [], inputs, 1.0)
            
            for sock in readable:
                if sock is browser_socket:
                    # Dane z przeglądarki
                    data = sock.recv(1024)
                    if not data:
                        print("Browser disconnected")
                        return
                        
                    if data[0] == 0x81:  # WebSocket text frame
                        print("Browser -> EV3 (WS frame)")
                        ev3_socket.send(data)
                    
                elif sock is ev3_socket:
                    # Dane z EV3
                    data = sock.recv(1024)
                    if not data:
                        print("EV3 disconnected")
                        return
                        
                    print("EV3 -> Browser")
                    browser_socket.send(data)
                    
            for sock in exceptional:
                print("Socket exception")
                return
                
        except Exception as e:
            print("Connection error: " + str(e))
            return

def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(('0.0.0.0', BROWSER_PORT))
    server.listen(1)
    print("Proxy listening on port " + str(BROWSER_PORT))

    while True:
        try:
            browser_socket, addr = server.accept()
            print("Browser connected from " + str(addr))
            
            ev3_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            print("Connecting to EV3...")
            ev3_socket.connect((EV3_HOST, EV3_PORT))
            print("Connected to EV3")
            
            # WebSocket handshake
            init_data = browser_socket.recv(1024)
            ev3_socket.send(init_data)
            response = ev3_socket.recv(1024)
            browser_socket.send(response)
            
            print("Starting WebSocket relay")
            handle_websocket_connection(browser_socket, ev3_socket)
            
        except Exception as e:
            print("Error: " + str(e))
        finally:
            try:
                browser_socket.close()
                ev3_socket.close()
            except:
                pass
        
        print("Connection closed, restarting...")

if __name__ == "__main__":
    main()
```

# ev3dev/websocket_test.py

```py
#!/usr/bin/env python3
import socket
import base64
import hashlib
import random
import sys

def create_websocket_key():
    random_bytes = bytes(random.getrandbits(8) for _ in range(16))
    return base64.b64encode(random_bytes).decode()

def create_handshake_request(host, port):
    key = create_websocket_key()
    request = (
        f"GET / HTTP/1.1\r\n"
        f"Host: {host}:{port}\r\n"
        "Upgrade: websocket\r\n"
        "Connection: Upgrade\r\n"
        f"Sec-WebSocket-Key: {key}\r\n"
        "Sec-WebSocket-Version: 13\r\n"
        "\r\n"
    )
    return request, key

def test_websocket():
    host = '192.168.2.3'
    port = 4000
    
    print(f"Connecting to {host}:{port}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        sock.connect((host, port))
        print("Connected!")
        
        request, key = create_handshake_request(host, port)
        print("Sending handshake...")
        sock.send(request.encode())
        
        response = sock.recv(1024).decode()
        print("\nReceived response:")
        print(response)
        
        # Test sending message
        print("\nSending test message...")
        sock.send(b"Hello from Python client!")
        
        data = sock.recv(1024)
        print("Received:", data)
        
    except Exception as e:
        print("Error:", str(e))
    finally:
        sock.close()

if __name__ == "__main__":
    test_websocket()
```

# hmi/config-overrides.js

```js
const { alias } = require('react-app-rewire-alias')
const webpackConfig = require('./webserver.config');

module.exports = function override(config, env) {
  // Wyłącz HMR i WebSocket
  config.devServer = {
    ...config.devServer,
    hot: false,
    webSocketServer: false
  };

  // Istniejące aliasy
  alias({
    '@components': 'src/components',
    '@styles': 'src/styles',
    '@types': 'src/types',
    '@utils': 'src/utils'
  })(config);

  return config;
}
```

# hmi/package.json

```json
{
  "name": "hmi",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@react-three/drei": "^9.97.0",
    "@react-three/fiber": "^8.15.15",
    "@types/cors": "^2.8.17",
    "cors": "^2.8.5",
    "leva": "^0.9.35",
    "lodash.clamp": "^4.0.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "stats.js": "^0.17.0",
    "three": "^0.161.0"
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@types/lodash.clamp": "^4.0.9",
    "@types/node": "^16.18.70",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "@types/three": "^0.160.0",
    "react-app-rewire-alias": "^1.1.7",
    "react-app-rewired": "^2.2.1",
    "typescript": "^4.9.5"
  },
  "scripts": {
    "start": "FAST_REFRESH=false WDS_SOCKET_PORT=0 GENERATE_SOURCEMAP=false react-app-rewired start",
    "dev": "npx serve -s build",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test",
    "eject": "react-app-rewired eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

```

# hmi/public/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="theme-color" content="#F84823"/>
    <meta name="description" content="Robotic Arm"/>
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json"/>
    <Style>
        html,
        body,
        #root {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            background: #303035;
        }
    </Style>
    <title>Robotic Arm</title>
</head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
</body>
</html>

```

# hmi/public/manifest.json

```json
{
  "short_name": "Robotic Arm",
  "name": "Robotic Arm Control Panel",
  "icons": [
    {
      "src": "favicon.png",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

```

# hmi/public/robot_v2.glb

This is a binary file of the type: Binary

# hmi/public/robot.glb

This is a binary file of the type: Binary

# hmi/public/robots.txt

```txt
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

```

# hmi/README.md

```md
# Hmi

### To do
- Persist matrix data
- Inverse Kinematics
- Material UI
- Redux Tookit
- 

```

# hmi/src/App.tsx

```tsx
import React, {useState, useEffect, useCallback} from 'react';
import {Canvas} from '@react-three/fiber';
import {GizmoHelper, GizmoViewport, OrbitControls, Environment, Stats, PerspectiveCamera} from '@react-three/drei';
import {Shadows, Ground} from '@components/stage';
import {Robot} from '@types';
import {RobotArm} from "@components/model/RobotArm";

const SOCKET_SERVER_URL = 'ws://localhost:4001';

export default function App() {
    const [robotData, setRobotData] = useState<Robot.RobotNodes>();    
    const [ws, setWs] = useState<WebSocket | null>(null);
    const [connectionStatus, setConnectionStatus] = useState('disconnected');
    const [error, setError] = useState<string>('');
    const [motorStatus, setMotorStatus] = useState<{[key: string]: string}>({
        base: 'unknown',
        elbow: 'unknown',
        height: 'unknown'
    });

    useEffect(() => {
        console.log('Connecting to:', SOCKET_SERVER_URL);
        const websocket = new WebSocket(SOCKET_SERVER_URL);
        
        websocket.onopen = () => {
            console.log('WebSocket Connected');
            setConnectionStatus('connected');
            setWs(websocket);
            
            // Request initial state
            // websocket.send(JSON.stringify({ action: 'test_motor' }));
        };

        websocket.onmessage = (event) => {
            console.log('Received raw message:', event.data);
            try {
                const response = JSON.parse(event.data);
                console.log('Parsed response:', response);
                
                if (response.state && response.state.nodes) {
                    console.log('Updating robot data with:', response.state);
                    setRobotData(response.state);
                }
                
                if (response.status === 'error') {
                    console.error('Server error:', response.message);
                    setError(response.message);
                }
                if (response.message) {
                    const newStatus = {...motorStatus};
                    if (response.message.includes('Base motor')) {
                        newStatus.base = response.message.includes('not available') ? 'disconnected' : 'connected';
                    }
                    if (response.message.includes('Elbow motor')) {
                        newStatus.elbow = response.message.includes('not available') ? 'disconnected' : 'connected';
                    }
                    if (response.message.includes('Height motor')) {
                        newStatus.height = response.message.includes('not available') ? 'disconnected' : 'connected';
                    }
                    setMotorStatus(newStatus);
                }
            } catch (e) {
                console.error('Parse error:', e);
            }
        };

        websocket.onclose = (event) => {
            console.log('WebSocket closed:', event);
            setConnectionStatus('disconnected');
            setWs(null);
        };
        
        websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            setConnectionStatus('error');
        };

        
        
        return () => websocket.close();
    }, []);

    const updateRobotData = useCallback((newData: Partial<Robot.RobotNodes>) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.error('WebSocket not connected');
            initWebSocket();
            return;
        }

        setRobotData(prevData => {
            if (prevData) {
                const updatedData = {...prevData, ...newData};
                console.log('Sending update:', updatedData);
                ws.send(JSON.stringify({
                    action: 'update',
                    ...updatedData
                }));
                return updatedData;
            }
            return prevData;
        });
    }, [ws])

    const initWebSocket = useCallback(() => {
        console.log('Initializing WebSocket...');
        const websocket = new WebSocket(SOCKET_SERVER_URL);
        
        websocket.onclose = (event) => {
            console.log('WebSocket closed:', event);
            // Próba ponownego połączenia po 1s
            setTimeout(initWebSocket, 1000);
        };
    
        websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
    
        setWs(websocket);
    }, []);
    
    useEffect(() => {
        initWebSocket();
        return () => ws?.close();
    }, []);


    useEffect(() => {
        console.log('=====>>>>', robotData)
    }, [robotData]);

    const testMotor = useCallback(() => {
        if (ws?.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: 'test_motor' }));
        } else {
            console.error('WebSocket not connected');
        }
    }, [ws]);

    useEffect(() => {
        console.log('Current robot data:', robotData);
    }, [robotData]);

    if (error) {
        return (
            <div style={{
                position: 'fixed',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                backgroundColor: '#ff4444',
                color: 'white',
                padding: '20px',
                borderRadius: '5px',
                textAlign: 'center'
            }}>
                <div>{error}</div>
                <button 
                    onClick={() => window.location.reload()}
                    style={{
                        marginTop: '10px',
                        padding: '5px 15px',
                        backgroundColor: 'white',
                        border: 'none',
                        borderRadius: '3px',
                        cursor: 'pointer'
                    }}
                >
                    Retry
                </button>
            </div>
        );
    }

    return (
        <>
            <div style={{
                position: 'fixed',
                top: '10px',
                left: '10px',
                zIndex: 1000,
                display: 'flex',
                flexDirection: 'column',
                gap: '10px'
            }}>
                <div style={{
                    padding: '5px',
                    background: connectionStatus === 'connected' ? '#4CAF50' : '#f44336',
                    color: 'white',
                    borderRadius: '4px'
                }}>
                    Socket Status: {connectionStatus}
                </div>
                <button
                    onClick={testMotor}
                    style={{
                        padding: '10px',
                        background: '#2196F3',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                    }}
                >
                    Test Motor
                </button>
                <div style={{
                    padding: '5px',
                    background: '#333',
                    color: 'white',
                    borderRadius: '4px'
                }}>
                    Motors: 
                    <br />
                    Base: {motorStatus.base}
                    <br />
                    Elbow: {motorStatus.elbow}
                    <br />
                    Height: {motorStatus.height}
                </div>
            </div>
            {robotData && (
                <Canvas>
                    <PerspectiveCamera makeDefault fov={40} position={[10, 8, 25]}/>
                    <RobotArm data={robotData} onUpdate={updateRobotData}/>
                    <Shadows/>
                    <Ground/>
                    <Environment preset="city"/>
                    <OrbitControls makeDefault/>
                    <GizmoHelper alignment="bottom-right" margin={[100, 100]}>
                        <GizmoViewport labelColor="white" axisHeadScale={1}/>
                    </GizmoHelper>
                    <Stats/>
                </Canvas>
            )}
        </>
    );
}
```

# hmi/src/components/gizmo/context.ts

```ts
 
import {createContext} from 'react'
import {Robot} from '@types'

export const context = createContext<Robot.GizmoState>(null!)

```

# hmi/src/components/gizmo/index.tsx

```tsx
import React, {useEffect, useRef} from 'react'
import {useThree} from '@react-three/fiber'
import {Translate} from './Translate'
import {Rotate} from './Rotate'
import {context} from './context'
import {Vector3, Matrix4, Box3, Group, Euler} from 'three'
import {Robot} from '@types'

const localMatrix = new Matrix4()
const localMatrix0 = new Matrix4()
const localMatrix0Inv = new Matrix4()
const localDeltaMatrix = new Matrix4()
const worldMatrix0 = new Matrix4()
const worldMatrix = new Matrix4()
const parentMatrix = new Matrix4()
const parentMatrixInv = new Matrix4()

export const Gizmo = ({
    scale = 1,
    matrix,
    anchor,
    activeAxes = [true, true, true],
    disableTranslation = false,
    disableRotation = false,
    translationLimits,
    rotationLimits,
    userData,
    onUpdate,
    children,
}: Robot.GizmoProperties) => {
    const invalidate = useThree((state) => state.invalidate)
    const parentGroup = useRef<Group>(null!)
    const matrixGroup = useRef<Group>(null!)
    const gizmoGroup = useRef<Group>(null!)
    const childrenGroup = useRef<Group>(null!)

    useEffect(() => {
        if (anchor) {
            const targetGroup = childrenGroup.current
            const boundingBox = new Box3()

            if (targetGroup) {
                targetGroup.updateWorldMatrix(true, true)
                parentMatrixInv.copy(targetGroup.matrixWorld).invert()
                boundingBox.makeEmpty()

                targetGroup.traverse((object: any) => {
                    if (!object.geometry) return
                    if (!object.geometry.boundingBox) object.geometry.computeBoundingBox()

                    localMatrix.copy(object.matrixWorld).premultiply(parentMatrixInv)
                    const objectBoundingBox = new Box3()
                    objectBoundingBox.copy(object.geometry.boundingBox)
                    objectBoundingBox.applyMatrix4(localMatrix)
                    boundingBox.union(objectBoundingBox)
                })

                const vectorCenter = new Vector3()
                const vectorSize = new Vector3()
                const anchorOffsetVector = new Vector3()
                const positionVector = new Vector3()

                vectorCenter.copy(boundingBox.max).add(boundingBox.min).multiplyScalar(0.5)
                vectorSize.copy(boundingBox.max).sub(boundingBox.min).multiplyScalar(0.5)
                anchorOffsetVector.copy(vectorSize).multiply(new Vector3(...anchor)).add(vectorCenter)
                positionVector.set(0, 0, 0).add(anchorOffsetVector)
                gizmoGroup.current.position.copy(positionVector)

                invalidate()
            }
        }
    }, [anchor, invalidate])

    const configuration = {
        onDragStart: () => {
            console.log('Drag start');
            localMatrix0.copy(matrixGroup.current.matrix)
            worldMatrix0.copy(matrixGroup.current.matrixWorld)
            invalidate()
        },

        onDrag: (worldDeltaMatrix: Matrix4) => {
            console.log('Dragging');
            parentMatrix.copy(parentGroup.current.matrixWorld)
            parentMatrixInv.copy(parentMatrix).invert()
            worldMatrix.copy(worldMatrix0).premultiply(worldDeltaMatrix)
            localMatrix.copy(worldMatrix).premultiply(parentMatrixInv)
            localMatrix0Inv.copy(localMatrix0).invert()
            localDeltaMatrix.copy(localMatrix).multiply(localMatrix0Inv)
            matrixGroup.current.matrix.copy(localMatrix)

            // Extract rotation from matrix
            
            const rotation = new Euler().setFromRotationMatrix(localMatrix);
            const rotationArray: [number, number, number] = [rotation.x, rotation.y, rotation.z];

            console.log('Updating rotation:', rotationArray);
            if (onUpdate) {
                onUpdate(rotationArray);
            }

            invalidate()
        },

        onDragEnd: () => {
            console.log('Drag end');
            invalidate()
        },

        translationLimits,
        rotationLimits,
        scale,
        userData
    }

    return (
        <context.Provider value={configuration}>
            <group ref={parentGroup}>
                <group ref={matrixGroup} matrix={matrix} matrixAutoUpdate={false}>
                    <group ref={gizmoGroup}>
                        {!disableTranslation && (
                            <>
                                {activeAxes[0] && <Translate axis={0}/>}
                                {activeAxes[1] && <Translate axis={1}/>}
                                {activeAxes[2] && <Translate axis={2}/>}
                            </>
                        )}
                        {!disableRotation && (
                            <>
                                {activeAxes[0] && activeAxes[1] && <Rotate axis={2}/>}
                                {activeAxes[0] && activeAxes[2] && <Rotate axis={1}/>}
                                {activeAxes[2] && activeAxes[1] && <Rotate axis={0}/>}
                            </>
                        )}
                    </group>
                    <group ref={childrenGroup}>{children}</group>
                </group>
            </group>
        </context.Provider>
    )
}
```

# hmi/src/components/gizmo/Rotate.tsx

```tsx
 
import React, {useContext, useRef, useState, useCallback, useMemo, FC} from 'react'
import {ThreeEvent, useThree} from '@react-three/fiber'
import {Line, Html} from '@react-three/drei'
import clamp from 'lodash.clamp'
import {context} from './context'
import {Vector3, Matrix4, Ray, Group, Plane} from 'three'
import {calculateAngle, toDegrees, toRadians, minimizeAngle} from '@utils'

/**
 * Rotate lets the user drag the gizmo and, with it, the child objects over the configured rotation axis/axes
 */
export const Rotate: FC<{ axis: 0 | 1 | 2 }> = ({axis}) => {

    // get the gizmo config & event implementations from context
    const {
        rotationLimits,
        scale,
        onDragStart,
        onDrag,
        onDragEnd,
        userData
    } = useContext(context)

    // determine directions
    const direction1 =
        axis === 2 ? new Vector3(1, 0, 0) :
            axis === 1 ? new Vector3(0, 0, 1) : new Vector3(0, 1, 0)
    const direction2 =
        axis === 2 ? new Vector3(0, 1, 0) :
            axis === 1 ? new Vector3(1, 0, 0) : new Vector3(0, 0, 1)

    // get a handle on the cam controls to enable/disable while operating the gizmo
    const camControls = useThree((state) => state.controls) as unknown as { enabled: boolean }

    // the label showing the rotated value
    const rotationLabel = useRef<HTMLDivElement>(null!)

    // Object3D group for this Gizmo
    const gizmoGroup = useRef<Group>(null!)

    // ref to keep info where the mouse/pointer click occurred
    const clickInfo = useRef<{
        clickPoint: Vector3
        origin: Vector3
        e1: Vector3
        e2: Vector3
        normal: Vector3
        plane: Plane
    } | null>(null)

    // is the mouse hovering over the gizmo. we change the color when hovering over
    const [isHovered, setIsHovered] = useState(false)

    // the angle calculated on start and used while moving
    const angle0 = useRef<number>(0)
    const angle = useRef<number>(0)

    /**
     * On pointer down (click) we prepare to start dragging
     */
    const onPointerDown = useCallback((event: ThreeEvent<PointerEvent>) => {

        // update label with rotation value
        rotationLabel.current.innerText = `${toDegrees(angle.current).toFixed(0)}°`
        rotationLabel.current.style.display = 'block'

        // avoid handlers firing
        event.stopPropagation()

        // get the xyz vector for the mouse click
        const clickPoint = event.point.clone()

        // @todo learn what is going on here
        const origin = new Vector3().setFromMatrixPosition(gizmoGroup.current.matrixWorld)
        const e1 = new Vector3().setFromMatrixColumn(gizmoGroup.current.matrixWorld, 0).normalize()
        const e2 = new Vector3().setFromMatrixColumn(gizmoGroup.current.matrixWorld, 1).normalize()
        const normal = new Vector3().setFromMatrixColumn(gizmoGroup.current.matrixWorld, 2).normalize()
        const plane = new Plane().setFromNormalAndCoplanarPoint(normal, origin)

        // set the click info
        clickInfo.current = {clickPoint, origin, e1, e2, normal, plane}

        // invoke drag start for rotation operation
        onDragStart({action: 'Rotate', axis, origin, directions: [e1, e2, normal]})

        // disable the cam controls to avoid it fighting with the gizmo movements
        camControls && (camControls.enabled = false)

        // @ts-ignore - setPointerCapture is not in the type definition
        event.target.setPointerCapture(event.pointerId)

    }, [camControls, onDragStart, axis])

    /**
     * Mouse/pointer moving
     */
    const onPointerMove = useCallback((event: ThreeEvent<PointerEvent>) => {

        // avoid handlers firing
        event.stopPropagation()

        if (!isHovered) setIsHovered(true)

        if (clickInfo.current) {

            const {clickPoint, origin, e1, e2, normal, plane} = clickInfo.current

            /**
             * Check if we are still within translation limits
             */
            const [min, max] = rotationLimits?.[axis] || [undefined, undefined]
            const ray = new Ray()
            const intersection = new Vector3()

            ray.copy(event.ray)
            ray.intersectPlane(plane, intersection)
            ray.direction.negate()
            ray.intersectPlane(plane, intersection)

            let deltaAngle = calculateAngle(clickPoint, intersection, origin, e1, e2)
            let degrees = toDegrees(deltaAngle)

            if (event.shiftKey) {
                degrees = Math.round(degrees / 10) * 10
                deltaAngle = toRadians(degrees)
            }

            if (min !== undefined && max !== undefined && max - min < 2 * Math.PI) {
                deltaAngle = minimizeAngle(deltaAngle)
                deltaAngle = deltaAngle > Math.PI ? deltaAngle - 2 * Math.PI : deltaAngle
                deltaAngle = clamp(deltaAngle, min - angle0.current, max - angle0.current)
                angle.current = angle0.current + deltaAngle
            } else {
                angle.current = minimizeAngle(angle0.current + deltaAngle)
                angle.current = angle.current > Math.PI ? angle.current - 2 * Math.PI : angle.current
            }

            // update label values
            degrees = toDegrees(angle.current)
            rotationLabel.current.innerText = `${degrees.toFixed(0)}°`

            const rotationMatrix = new Matrix4()
            const posNew = new Vector3()

            rotationMatrix.makeRotationAxis(normal, deltaAngle)
            posNew.copy(origin).applyMatrix4(rotationMatrix).sub(origin).negate()
            rotationMatrix.setPosition(posNew)

            // invoke the onDrag method with the calculated rotation matrix
            onDrag(rotationMatrix)
        }

    }, [onDrag, isHovered, rotationLimits, axis])

    /**
     * Pointer up ends the gizmo interaction
     */
    const onPointerUp = useCallback((event: ThreeEvent<PointerEvent>) => {

        // hide label
        rotationLabel.current.style.display = 'none'

        // avoid handlers firing
        event.stopPropagation()

        angle0.current = angle.current

        // reset click info
        clickInfo.current = null

        // call the onDragEnd
        onDragEnd()

        // give cam controls back
        camControls && (camControls.enabled = true)

        // @ts-ignore - releasePointerCapture & PointerEvent#pointerId is not in the type definition
        event.target.releasePointerCapture(event.pointerId)

    }, [camControls, onDragEnd])

    /**
     * In the pointer out we mark hovered as false
     */
    const onPointerOut = useCallback((event: ThreeEvent<PointerEvent>) => {
        // avoid handlers firing
        event.stopPropagation()
        setIsHovered(false)
    }, [])


    /**
     * Gizmo group matrix
     */
    const matrix = useMemo(() => {
        const dir1N = direction1.clone().normalize()
        const dir2N = direction2.clone().normalize()
        return new Matrix4().makeBasis(dir1N, dir2N, dir1N.clone().cross(dir2N))
    }, [direction1, direction2])

    const r = scale * 0.65

    /**
     * Calculate gizmo arc shape
     */
    const arc = useMemo(() => {
        const segments = 32
        const points: Vector3[] = []
        for (let j = 0; j <= segments; j++) {
            const angle = (j * (Math.PI / 2)) / segments
            points.push(new Vector3(Math.cos(angle) * r, Math.sin(angle) * r, 0))
        }
        return points
    }, [r])

    // colors of the axes and a hover color
    const axisColors = ['#ff2060', '#20df80', '#2080ff']
    const color = isHovered ? '#ffff40' : axisColors[axis]

    return (
        <group ref={gizmoGroup}
               onPointerDown={onPointerDown}
               onPointerMove={onPointerMove}
               onPointerUp={onPointerUp}
               onPointerOut={onPointerOut}
               matrix={matrix}
               matrixAutoUpdate={false}>

            {/** the label showing the rotation value */}
            <Html position={[r, r, 0]}>
                <div
                    style={{
                        display: 'none',
                        fontFamily: 'monospace',
                        background: '#F84823',
                        color: 'white',
                        padding: '6px 8px',
                        borderRadius: 7,
                        whiteSpace: 'nowrap'
                    }}
                    ref={rotationLabel}
                />
            </Html>

            {/* The invisible mesh being raycast */}
            <Line points={arc} lineWidth={8} visible={false} userData={userData}/>

            {/* The visible mesh */}
            <Line
                transparent
                raycast={() => null}
                points={arc}
                lineWidth={2}
                color={color}
                polygonOffset
                polygonOffsetFactor={-10}
            />

        </group>
    )
}

```

# hmi/src/components/gizmo/Translate.tsx

```tsx
 
import React, {useContext, useCallback, useMemo, useRef, useState, FC} from 'react'
import {ThreeEvent, useThree} from '@react-three/fiber'
import {Line, Html} from '@react-three/drei'
import {context} from './context'
import {Vector3, Matrix4, Group, Quaternion} from 'three'
import {calculateOffset} from '@utils'

/**
 * Translate lets the user drag the gizmo and, with it, the child objects over the configured translation axis/axes
 */
export const Translate: FC<{ axis: 0 | 1 | 2 }> = ({axis}) => {

    // get the gizmo config & event implementations from context
    const {
        translationLimits,
        scale,
        onDragStart,
        onDrag,
        onDragEnd,
        userData
    } = useContext(context)

    // determine direction.
    const direction =
        axis === 0 ? new Vector3(1, 0, 0) :
            axis === 1 ? new Vector3(0, 1, 0) : new Vector3(0, 0, 1)

    // get a handle on the cam controls to enable/disable while operating the gizmo
    const camControls = useThree((state) => state.controls) as unknown as { enabled: boolean }

    // the label showing the translated value
    const translationLabel = useRef<HTMLDivElement>(null!)

    // Object3D group for this Gizmo
    const gizmoGroup = useRef<Group>(null!)

    // ref to keep info where the mouse/pointer click occurred
    const clickInfo = useRef<{ clickPoint: Vector3; dir: Vector3 } | null>(null)

    // the offset calculated on start and used while moving
    const offset0 = useRef<number>(0)

    // is the mouse hovering over the gizmo. we change the color when hovering over
    const [isHovered, setIsHovered] = useState(false)

    const translation = useRef<[number, number, number]>([0, 0, 0])

    /**
     * On pointer down (click) we prepare to start dragging
     */
    const onPointerDown = useCallback((event: ThreeEvent<PointerEvent>) => {

            // update label with current translation value for this axis and show it
            translationLabel.current.innerText = `${translation.current[axis].toFixed(2)}`
            translationLabel.current.style.display = 'block'

            // stopPropagation will stop underlying handlers from firing
            event.stopPropagation()

            // get the xyz vector for the mouse click
            const clickPoint = event.point.clone()

            // @todo learn what is going on here
            const rotation = new Matrix4().extractRotation(gizmoGroup.current.matrixWorld)
            const origin = new Vector3().setFromMatrixPosition(gizmoGroup.current.matrixWorld)
            const dir = direction.clone().applyMatrix4(rotation).normalize()

            // set the click info
            clickInfo.current = {clickPoint, dir}
            offset0.current = translation.current[axis]

            // invoke drag start for translation operation
            onDragStart({action: 'Translate', axis, origin, directions: [dir]})

            // disable the cam controls to avoid it fighting with the gizmo movements
            camControls && (camControls.enabled = false)

            // @ts-ignore - setPointerCapture is not in the type definition
            event.target.setPointerCapture(event.pointerId)

        }, [direction, camControls, onDragStart, translation, axis]
    )

    /**
     * Mouse/pointer moving
     */
    const onPointerMove = useCallback((event: ThreeEvent<PointerEvent>) => {

            // stopPropagation will stop underlying handlers from firing
            event.stopPropagation()

            if (!isHovered) setIsHovered(true)

            if (clickInfo.current) {

                const {clickPoint, dir} = clickInfo.current

                /**
                 * Check if we are still within translation limits
                 */
                const [min, max] = translationLimits?.[axis] || [undefined, undefined]
                let offset = calculateOffset(clickPoint, dir, event.ray.origin, event.ray.direction)
                if (min !== undefined) offset = Math.max(offset, min - offset0.current)
                if (max !== undefined) offset = Math.min(offset, max - offset0.current)

                // set the current translation
                translation.current[axis] = offset0.current + offset

                // update label with translation value
                translationLabel.current.innerText = `${translation.current[axis].toFixed(2)}`

                // create and calculate the offset matrix for the on drag method
                const offsetMatrix = new Matrix4().makeTranslation(dir.x * offset, dir.y * offset, dir.z * offset)

                // invoke the onDrag method with the calculated offset matrix
                onDrag(offsetMatrix)
            }

        }, [onDrag, isHovered, translation, translationLimits, axis]
    )

    /**
     * Pointer up ends the gizmo interaction
     */
    const onPointerUp = useCallback((event: ThreeEvent<PointerEvent>) => {

            // hide label
            translationLabel.current.style.display = 'none'

            // avoid handlers firing
            event.stopPropagation()

            // reset click info
            clickInfo.current = null

            // call the onDragEnd
            onDragEnd()

            // give cam controls back
            camControls && (camControls.enabled = true)

            // @ts-ignore - releasePointerCapture & PointerEvent#pointerId is not in the type definition
            event.target.releasePointerCapture(event.pointerId)

        }, [camControls, onDragEnd]
    )

    /**
     * In the pointer out we mark hovered as false
     */
    const onPointerOut = useCallback((event: ThreeEvent<PointerEvent>) => {
        // avoid handlers firing
        event.stopPropagation()
        setIsHovered(false)
    }, [])

    // calculate properties for the translation arrow meshes
    const {cylinderLength, coneWidth, coneLength, matrix} = useMemo(() => {
        const coneWidth = scale / 20
        const coneLength = scale / 5
        const cylinderLength = scale - coneLength
        const quaternion = new Quaternion().setFromUnitVectors(new Vector3(0, 1, 0), direction.clone().normalize())
        const matrixL = new Matrix4().makeRotationFromQuaternion(quaternion)
        return {cylinderLength, coneWidth, coneLength, matrix: matrixL}
    }, [direction, scale])

    // colors of the axes and a hover color
    const axisColors = ['#ff2060', '#20df80', '#2080ff']
    const color = isHovered ? '#ffff40' : axisColors[axis]

    return (
        <group ref={gizmoGroup}>

            {/** group on which we set the gizmo event implementations */}
            <group
                matrix={matrix}
                matrixAutoUpdate={false}
                onPointerDown={onPointerDown}
                onPointerMove={onPointerMove}
                onPointerUp={onPointerUp}
                onPointerOut={onPointerOut}>

                {/** the label showing the translation value */}
                <Html position={[0, -coneLength, 0]}>
                    <div
                        style={{
                            display: 'none',
                            fontFamily: 'monospace',
                            background: '#F84823',
                            color: 'white',
                            padding: '6px 8px',
                            borderRadius: 7,
                            whiteSpace: 'nowrap'
                        }}
                        ref={translationLabel}
                    />
                </Html>

                {/* The invisible mesh being raycast
                    @todo learn how this works
                 */}
                <mesh visible={false} position={[0, (cylinderLength + coneLength) / 2.0, 0]} userData={userData}>
                    <cylinderGeometry args={[coneWidth * 1.4, coneWidth * 1.4, cylinderLength + coneLength, 8, 1]}/>
                </mesh>

                {/* The visible mesh */}
                <Line transparent
                      raycast={() => null}
                      points={[0, 0, 0, 0, cylinderLength, 0]}
                      lineWidth={2}
                      color={color}
                      polygonOffset
                      renderOrder={1}
                      polygonOffsetFactor={-10}/>
                <mesh raycast={() => null} position={[0, cylinderLength + coneLength / 2.0, 0]} renderOrder={500}>
                    <coneGeometry args={[coneWidth, coneLength, 24, 1]}/>
                    <meshBasicMaterial transparent={true} color={color}/>
                </mesh>

            </group>
        </group>
    )
}

```

# hmi/src/components/mesh/Mesh.tsx

```tsx
 
import React from 'react'
import {Robot} from '@types'
import { Euler } from 'three'

/**
 * Defines a Mesh with material and location
 *
 * @param node The GLTF Mesh
 * @param data The node 3d data
 */


const Mesh = ({node, data}: Robot.MeshProperties) => {
    //   @ts-ignore
    const rotation = data.rotation.length > 0 ? new Euler().fromArray(data.rotation) : new Euler(0, 0, 0)

    return (
        <mesh geometry={node.geometry}
              material={node.material}
              position={data.position}
              rotation={rotation}
              scale={data.scale}
        />
    )
}

export default Mesh

```

# hmi/src/components/model/index.ts

```ts
 

/**
 * The model folder contains the models we want to render.
 * Model is created in Blender, exported to glb and converted to tsx.
 *
 * Using a Barrel for clean import
 */
export {RobotArm} from './RobotArm'

```

# hmi/src/components/model/RobotArm.tsx

```tsx
import {Gizmo} from '@components/gizmo'
import {useGLTF} from '@react-three/drei'
import {Robot} from '@types'
import Mesh from "@components/mesh/Mesh"

interface RobotProps {
    data: Robot.RobotNodes;
    onUpdate: (newData: Partial<Robot.RobotNodes>) => void;
}

export const RobotArm = ({data, onUpdate}: RobotProps) => {
    const {nodes} = useGLTF('/robot.glb') as unknown as Robot.DreiGLTF;
    const node = Robot.NodeName;

    const handleGizmoUpdate = (nodeName: Robot.NodeName, newMatrix: [number, number, number]) => {
        console.log(`Updating ${nodeName}:`, newMatrix);
        
        const newData: Partial<Robot.RobotNodes> = {
            nodes: {
                ...data.nodes,
                [nodeName]: {
                    ...data.nodes[nodeName],
                    position: data.nodes[nodeName].position,
                    scale: data.nodes[nodeName].scale,
                    rotation: data.nodes[nodeName].rotation,
                    _updated: true
                }
            }
        };
    
        // Preserve initial rotations for hand and gripper
        if (newData.nodes) {
            if (newData.nodes.hand) {
                newData.nodes.hand.rotation = data.nodes.hand.rotation;
            }
            if (newData.nodes.gripper && nodeName !== node.gripper) {
                newData.nodes.gripper.rotation = data.nodes.gripper.rotation;
            }
        }
    
        // Reset _updated flag for other nodes
        Object.keys(newData.nodes || {}).forEach((key) => {
            // @ts-ignore
            if (key !== nodeName && newData.nodes && newData.nodes[key]) {
                // @ts-ignore
                newData.nodes[key]._updated = false;
            }
        });
    
        console.log('Sending update:', newData);
        onUpdate(newData);
    };

    return (
        <group>
            <Gizmo scale={5}
                   disableTranslation
                   activeAxes={[true, false, true]}
                   userData={[node.mainColumn]}
                   onUpdate={(newMatrix) => handleGizmoUpdate(node.mainColumn, newMatrix)}>
                <Mesh node={nodes[node.mainColumn]} data={data.nodes[node.mainColumn]}/>

                <Gizmo activeAxes={[false, true, false]}
                       translationLimits={[undefined, [-1, .8], undefined]}
                       disableRotation
                       anchor={[-0.8, 1.5, 0]}
                       scale={1}
                       userData={[node.upperArm]}
                       onUpdate={(newMatrix) => handleGizmoUpdate(node.upperArm, newMatrix)}>

                    <Mesh node={nodes[node.upperArm]} data={data.nodes[node.upperArm]}/>
                    <Mesh node={nodes[node.wristExtension]} data={data.nodes[node.wristExtension]}/>
                    <Mesh node={nodes[node.hand]} data={data.nodes[node.hand]}/>

                    <Gizmo activeAxes={[false, false, true]}
                           translationLimits={[undefined, undefined, [0, 0.4]]}
                           anchor={[2, 0, 2]}
                           scale={0.75}
                           userData={[node.gripper]}
                           onUpdate={(newMatrix) => handleGizmoUpdate(node.gripper, newMatrix)}>
                        <Mesh node={nodes[node.gripper]} data={data.nodes[node.gripper]}/>
                    </Gizmo>
                </Gizmo>
            </Gizmo>
        </group>
    );
};

useGLTF.preload('/robot.glb');
```

# hmi/src/components/stage/Ground.tsx

```tsx
 
import React from 'react'
import {Grid} from '@react-three/drei'

/**
 * A drei Grid providing a plane for the model to be presented on
 *
 * @todo move properties to user/app configuration
 */
export const Ground = () => {

    return <Grid position={[0, -0.01, 0]}
                 args={[10.5, 10.5]}
                 cellSize={0.5}
                 cellThickness={0.5}
                 cellColor={'#6f6f6f'}
                 sectionSize={3}
                 sectionThickness={1}
                 sectionColor={'#9d4b4b'}
                 fadeDistance={30}
                 fadeStrength={1}
                 followCamera={false}
                 infiniteGrid={true}/>
}

```

# hmi/src/components/stage/index.ts

```ts
 

/**
 * The stage folder contains the 'stage' Components,
 * visual elements that define the environment our models
 * appear in such as Lights, floors, shadows, ambient lights
 *
 * Using a Barrel for clean import
 */
export {Shadows} from './Shadows'
export {Ground} from './Ground'

```

# hmi/src/components/stage/Shadows.tsx

```tsx
 
import React, {memo} from 'react'
import {AccumulativeShadows, RandomizedLight} from '@react-three/drei'

/**
 * Providing natural looking shadow/light
 */
export const Shadows = memo(() => (
    <AccumulativeShadows temporal frames={100} color="#9d4b4b" colorBlend={0.5} alphaTest={0.9} scale={20}>
        <RandomizedLight amount={8} radius={4} position={[5, 5, -10]}/>
    </AccumulativeShadows>
))

```

# hmi/src/index.tsx

```tsx
 
import React from 'react'
import App from './App'
import ReactDOM from 'react-dom/client'

// Render the App on the root div
const root = ReactDOM.createRoot(
    document.getElementById('root') as HTMLElement
)

root.render(<App/>)

```

# hmi/src/types/index.ts

```ts
 
import {ReactNode} from 'react'
import {GLTF} from 'three/examples/jsm/loaders/GLTFLoader'
import {Vector3, Mesh, MeshStandardMaterial, Matrix4} from 'three'

/**
 * Types for the project
 */
export namespace Robot {

    /**
     * The Node names we expect on a Robot
     */
    export enum NodeName {
        mainColumn = 'main_column',
        upperArm = 'upper_arm',
        wristExtension = 'wrist_extension',
        hand = 'hand',
        gripper = 'gripper'
    }

    /**
     * Nodes expected in robot data
     */
    export interface RobotNodes {
        nodes: {
            [NodeName.mainColumn]: RobotNode,
            [NodeName.upperArm]: RobotNode,
            [NodeName.wristExtension]: RobotNode,
            [NodeName.hand]: RobotNode,
            [NodeName.gripper]: RobotNode
        }
    }

    /**
     * Robot Node data
     */
    export interface RobotNode {
        position: Vector3,
        scale: Vector3
        rotation?: Vector3
    }

    /**
     * Since useGLTF does not supply the nodes and materials types we define them ourselves.
     * Seems like missing typing in drei.
     */
    export type DreiGLTF = GLTF & {
        nodes: Record<string, Mesh>
        materials: Record<string, MeshStandardMaterial>
    }

    /**
     * With mesh and robot data we construct each Robot node
     */
    export type MeshProperties = {
        node: Mesh
        data: RobotNode
    }

    /**
     * Properties we receive for a Robot Gizmo
     */
    export type GizmoProperties = {

        // gizmo scale
        scale?: number

        // start matrix
        matrix?: Matrix4

        // gizmo anchor
        anchor?: [number, number, number]

        // axis to operate on
        activeAxes?: [boolean, boolean, boolean]

        // switch off all rotation or translation
        disableTranslation?: boolean
        disableRotation?: boolean

        // translation limits array: x:[start,end] y[start,end] z[start,end]
        translationLimits?: [[number, number] | undefined, [number, number] | undefined, [number, number] | undefined]

        // rotation limits array: x:[start,end] y[start,end] z[start,end]
        rotationLimits?: [[number, number] | undefined, [number, number] | undefined, [number, number] | undefined]

        // custom data
        userData?: { [key: string]: any }
        
        children?: ReactNode

        onUpdate: (matrix: [number, number, number]) => void

    }

    /**
     * The state we hold for a Gizmo
     */
    export type GizmoState = {
        onDragStart: (props: GizmoStart) => void
        onDrag: (local: Matrix4) => void
        onDragEnd: () => void
        translationLimits?: [[number, number] | undefined, [number, number] | undefined, [number, number] | undefined]
        rotationLimits?: [[number, number] | undefined, [number, number] | undefined, [number, number] | undefined]
        scale: number
        userData?: { [key: string]: any }
    }

    /**
     * The start event when Gizmo is invoked
     */
    export type GizmoStart = {
        action: 'Translate' | 'Rotate'
        axis: 0 | 1 | 2
        origin: Vector3
        directions: Vector3[]
    }
}

```

# hmi/src/utils/index.ts

```ts
 
import {Vector3} from "three";

/**
 * Calculate degrees from radians
 * @param radians
 */
const toDegrees = (radians: number) => (radians * 180) / Math.PI

/**
 * Calculate radians from degrees
 * @param degrees
 */
const toRadians = (degrees: number) => (degrees * Math.PI) / 180

/**
 *
 * @param clickPoint
 * @param intersectionPoint
 * @param origin
 * @param e1
 * @param e2
 */
const calculateAngle = (clickPoint: Vector3, intersectionPoint: Vector3, origin: Vector3, e1: Vector3, e2: Vector3) => {

    const clickDir = new Vector3()
    const intersectionDir = new Vector3()

    clickDir.copy(clickPoint).sub(origin)
    intersectionDir.copy(intersectionPoint).sub(origin)

    const dote1e1 = e1.dot(e1)
    const dote2e2 = e2.dot(e2)
    const uClick = clickDir.dot(e1) / dote1e1
    const vClick = clickDir.dot(e2) / dote2e2
    const uIntersection = intersectionDir.dot(e1) / dote1e1
    const vIntersection = intersectionDir.dot(e2) / dote2e2
    const angleClick = Math.atan2(vClick, uClick)
    const angleIntersection = Math.atan2(vIntersection, uIntersection)

    return angleIntersection - angleClick
}

/**
 *
 * @param num
 * @param denom
 */
const fmod = (num: number, denom: number) => {

    let k = Math.floor(num / denom)
    k = k < 0 ? k + 1 : k

    return num - k * denom
}

/**
 *
 * @param angle
 */
const minimizeAngle = (angle: number) => {

    let result = fmod(angle, 2 * Math.PI)

    if (Math.abs(result) < 1e-6) {
        return 0.0
    }

    if (result < 0.0) {
        result += 2 * Math.PI
    }

    return result
}

/**
 * Helper method to calculate the offset when determining
 * if we are still within translation limits
 * @todo move to utils
 */
const calculateOffset = (clickPoint: Vector3, normal: Vector3, rayStart: Vector3, rayDir: Vector3) => {

    const vec1 = new Vector3()
    const vec2 = new Vector3()
    const e1 = normal.dot(normal)
    const e2 = normal.dot(clickPoint) - normal.dot(rayStart)
    const e3 = normal.dot(rayDir)

    if (e3 === 0) return -e2 / e1

    vec1.copy(rayDir).multiplyScalar(e1 / e3).sub(normal)
    vec2.copy(rayDir).multiplyScalar(e2 / e3).add(rayStart).sub(clickPoint)

    return -vec1.dot(vec2) / vec1.dot(vec1)
}

export {
    toDegrees,
    toRadians,
    calculateAngle,
    fmod,
    minimizeAngle,
    calculateOffset
}

```

# hmi/tsconfig.json

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@components/*": [
        "src/components/*"
      ],
      "@styles": [
        "src/styles"
      ],
      "@types": [
        "src/types"
      ],
      "@utils": [
        "src/utils"
      ]
    },
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}

```

# hmi/webserver.config.js

```js
module.exports = {
  devServer: {
    hot: false,
    webSocketServer: false
  }
};
```

# model/crane copy.blend

This is a binary file of the type: Binary

# model/crane_lego.blend

This is a binary file of the type: Binary

# model/crane.blend

This is a binary file of the type: Binary

# model/crane.blend1

This is a binary file of the type: Binary

# model/crane.glb

This is a binary file of the type: Binary

# model/Crane.jsx

```jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 ./hmi/public/robot_v2.glb 
*/

import React from 'react'
import { useGLTF } from '@react-three/drei'

export function Model(props) {
  const { nodes, materials } = useGLTF('/robot_v2.glb')
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.main_column.geometry} material={nodes.main_column.material} position={[0, 1.462, 0]} />
      <mesh geometry={nodes.upper_arm.geometry} material={nodes.upper_arm.material} position={[2.335, 0, 0.094]} scale={[0.684, 1, 1]} />
      <mesh geometry={nodes.wrist_extension.geometry} material={nodes.wrist_extension.material} position={[3.241, 6.541, 0.007]} scale={0.264} />
      <mesh geometry={nodes.hand.geometry} material={nodes.hand.material} position={[3.318, 5.71, -0.101]} rotation={[0, Math.PI / 2, 0]} scale={[1, 0.068, 0.327]} />
      <mesh geometry={nodes.gripper.geometry} material={nodes.gripper.material} position={[3.275, 5.505, 0.286]} rotation={[Math.PI, -Math.PI / 2, 0]} scale={[-0.01, -0.132, -0.325]} />
    </group>
  )
}

useGLTF.preload('/robot_v2.glb')

```

# model/README.md

```md
# Model

## Process

### Create Model in Blender

When modeling, mind the origins of the meshes.

- Create 1 mesh for those elements that need a gizmo for translating / rotating
- 

of what you want to : move object when replacing origin, only scale and move in edit mode to preserve origin and prevent needing scaling data

### Export to glb/glTF

Blender has an option to export your mesh to glb/glTF

### Convert to JSX

Use [GLB to JSX Converter](https://github.com/pmndrs/gltfjsx) to convert the glb/glTF file from blender 
to a ready to use jsx file.

\`\`\`shell
  npx gltfjsx Model.glb
\`\`\`

```

# model/robot_v2.glb

This is a binary file of the type: Binary

# package.json

```json
{
  "dependencies": {
    "serialport": "^12.0.0"
  }
}

```

# README.md

```md
# Robotic Arm

## Intro

### Copy file from MacOS
scp ev3.py robot@ev3dev.local:/home/robot/

### Run on EV3
chmod +x ev3.py
./ev3.py

### Check connection
nc -v 192.168.3.1 4000 

### USB
Widzę problem - routing idzie przez en0 zamiast en13.
netstat -nr | grep 192.168.2 

Usuń obecną trasę 
sudo route delete 192.168.2.0/24 

Dodaj poprawną trasę przez en13 sudo route add -net 
192.168.2.0/24 -interface en13

### Reset USB
sudo ifconfig en13 down
sudo route flush 

sudo ifconfig en13 192.168.2.1 netmask 255.255.255.0 up 
sudo route -n add -net 192.168.2.0/24 -interface en13

ping -c 3 192.168.3.1

### wscat
wscat -c ws://192.168.2.3:4000 

### EV3
ip -4 addr show usb0
netstat -nr



```

# Robot_v2.jsx

```jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 ./hmi/public/robot_v2.glb 
*/

import React from 'react'
import { useGLTF } from '@react-three/drei'

export function Model(props) {
  const { nodes, materials } = useGLTF('/robot_v2.glb')
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.main_column.geometry} material={nodes.main_column.material} position={[0, 1.462, 0]} />
      <mesh geometry={nodes.upper_arm.geometry} material={nodes.upper_arm.material} position={[2.335, 0, 0.094]} scale={[0.684, 1, 1]} />
      <mesh geometry={nodes.wrist_extension.geometry} material={nodes.wrist_extension.material} position={[3.241, 6.541, 0.007]} scale={0.264} />
      <mesh geometry={nodes.hand.geometry} material={nodes.hand.material} position={[3.318, 5.71, -0.101]} rotation={[0, Math.PI / 2, 0]} scale={[1, 0.068, 0.327]} />
      <mesh geometry={nodes.gripper.geometry} material={nodes.gripper.material} position={[3.275, 5.505, 0.286]} rotation={[Math.PI, -Math.PI / 2, 0]} scale={[-0.01, -0.132, -0.325]} />
    </group>
  )
}

useGLTF.preload('/robot_v2.glb')

```

# Robot.jsx

```jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 ./hmi/public/robot.glb 
*/

import React from 'react'
import { useGLTF } from '@react-three/drei'

export function Model(props) {
  const { nodes, materials } = useGLTF('/robot.glb')
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.main_column.geometry} material={nodes.main_column.material} position={[0, 1.462, 0]} />
      <mesh geometry={nodes.upper_arm.geometry} material={nodes.upper_arm.material} position={[2.335, 0, 0.094]} scale={[0.684, 1, 1]} />
      <mesh geometry={nodes.wrist_extension.geometry} material={nodes.wrist_extension.material} position={[3.241, 6.541, 0.007]} scale={0.264} />
      <mesh geometry={nodes.hand.geometry} material={nodes.hand.material} position={[3.918, 5.71, 0.049]} scale={[1, 0.068, 0.327]} />
      <mesh geometry={nodes.gripper.geometry} material={nodes.gripper.material} position={[4.355, 5.515, 0.006]} rotation={[-Math.PI, 0, 0]} scale={[-0.01, -0.132, -0.325]} />
    </group>
  )
}

useGLTF.preload('/robot.glb')

```

